'Esta secci'on est'a dirigida al corrector del presente trabajo y ya no a los Timbalistas. Lo que deseamos es plasmar todos los problemas que tuvimos en su realizaci'on, experiencias aprendidas y, capaz, algunos de los momentos de p'anico. .

\subsection{Primeros conceptos: cualquiera}
Nadie en el grupo entr'o a la materia con s'olidos conceptos de dise'no. Los 'unicos que ten'iamos eran los brindados por las clases pr'acticas. Pero no es el mismo tipo de dise'no el que se realiza para un ejercicio que para un trabajo pr'actico. 'Esto nos llev'o a un primer dise'no (del servidor) en donde se agarr'o al modelo conceptual del TP1 y se trat'o de agregar operaciones y dependencias (a'un sabiendo que eso no estaba bien, pero no se nos ocurr'ia otra forma). De ah'i quedaron cosas como que la clase Jugador representaba a un jugador dentro del casino y a la vez representaba al jugador real (persona usuario del sistema) porque era el encargado de realizar las apuestas en una mesa. Adem'as el jugador era el que jugaba (o sea, invocaba la operaci'on de jugar sobre una mesa) porque, \italica{obviamente}, un jugador juega!

Luego nos dimos cuenta que en realidad existen otras entidades adicionales que no se ven en el modelo conceptual, clases que permiten la recepci'on de mensajes y ejecutan las acciones correspondientes para modificar el estado del (aunque todavia no lo llam'abamos as'i) Modelo. M'as adelante nos dimos cuenta que el modelo conceptual representa solamente a las estructuras y l'ogica de negocio del casino.


\subsection{Problemas con MVC}
Despu'es de darnos cuenta que deb'iamos establecer, como dise'no a gran escala, clases (o un conjunto de ellas) que faciliten la comunicaci'on con los clientes, otras que sepan leer los mensajes y actuar en funci'on de ello, otras que representen la funcionalidad innata del problema (l'ogica de negocio) y otras que generen las respuestas a los clientes. Algunos miembros del grupo ten'ian unas nocione del patr'on Model-View-Controller el cual es muy utilizado en aplicaciones web. Y, en principio, el servidor aparentaba un servidor web (que se maneja con XMLs en lugar de HTMLs) y los clientes, los navegadores web.

Para ello nos bas'amos en el MVC propuesto para Java (\cite{MVC-Java}). Pero lo comprendimos mal. El mayor error fue condiderar que en el Modelo solamente est'an las estructuras referentes a la l'ogica de negocio del problema pero nada de l'ogica (una especie de repositorio de datos espec'ificos del problema que queremos resolver). Y en el Controlador supusimos que deb'ia estar la l'ogica encargada de leer los pedidos y ejecutar ellos mismos la l'ogica de negocio, utilizando los datos que encuentra en el Modelo. Al principio parec'ia que iba a funcionar. Pero comezaron a surgir cosas que no nos cerraban:

\begin{itemize}
\item la cohesi'on entre la l'ogica y los datos era m'inima y no deber'ia ser as'i porque uno esta muy relacionado al otro.
\item el controlador realizaba las tareas de l'ogica del casino y a la vez el parseo de los XML.
\item ten'iamos que si o si utilizar condicionales hasta para la menor decisi'on posible (eso es porque no pod'iamos utilizar el \italica{strategy}, ya que estar'iamos dandole l'ogica de negocio al Modelo, y eso nos parecia mal)
\end{itemize}

Despu'es de estar semanas bajo 'este paradigma, lleg'o un punto que todos 'estos problemas eran intratables. All'i nos dimos cuenta de nuestro error. Entramos en p'anico. No pudimos continuar hasta no consultar c'omo realmente utilizar MVC. El corrector nos dijo que el verdadero MVC no era soportado por el protocolo por no tener mensajes que le permitan al Modelo actualizar a la Vista. Y nos dijo y repiti'o que no usemos MVC. Entonces adoptamos el diagrama actual, en donde el MensajeroDeSalida (ex Controlador) s'olo sabe parsear los XML y toda la l'ogica la realiza el Modelo. 

Realmente todo lo que tuvimos que pensar y debatir en grupo bas'andonos en un paradigma err'oneo nos permiti'o darnos cuenta porque es que el enfoque no serv'ia, y porque se debe pegar la logica a la representaci'on si queremos tomar un enfoque orientado a objetos (capaz que con un repositorio de datos basado en, por ejemplo, una base de datos relacional el enfoque cambiar'ia porque las ventajas y desventajas comparadas con la orientaci'on a objetos son diferentes).


\subsection{?`C'omo y d'onde hacer el ``dynamic cast''?}
Algo que nos carcomi'o mucho la cabeza fue c'omo darle sentido a los valores de un pedido (un XML, el cual puede ser considerado un simple texto) y as'i saber de que mensaje se trata para saber como tratarlo, al igual que qui'en es el encargado de hacer el \italica{parseo} de texto al valor que ya sabe debe ser. Estabamos hablando, si se quiere usar un nombre m'as lindo, sobre donde y como hacer el \italica{dynamic cast}. A medida que fuimos d'andole forma al dise'no, nos tuvimos que ir tomando la decisi'on varias veces, siempre tratando que sea lo m'as transparente posible y que sea en un s'olo lugar. Terminamos convergiendo a que sea toda tarea del MensajeroDeEntrada: el DespachadorPedidos realiza el primer paso eligiendo quien es el responsable de manejar el pedido que acaba de llegar, y luego cada manejador hace el segundo paso al saber como recorrer el XML y comprendiendo que valor representa el texto que le llega (en realidad s'olo hablando de tipos, por ejemplo puede saber que un IdMesa es un Entero pero no comprende que es un valor que representa a una mesa porque es l'ogica s'olo del Modelo). 

El enfoque de dejar todo 'esto en un s'olo lugar trae como consecuencia (una consecuencia justamente buscada) que si el protocolo cambia, ya sea la estructura (se pasa de XML a otra estructura) o la sintaxis de los mensajes, 'estos cambios s'olo afectar'an al MensajeroDeEntrada. Lo cual va de la mano al Single Responsability Principle.


\subsection{Poco grado de paralelismo en el grupo}
Ya en la realizaci'on del TP1 nos dimos cuenta que el enfoque de 'estos trabajos pr'acticos no era igual a los de otras materias. Aqu'i no s'olo hay que tomar muchas m'as decisiones si no que adem'as las posibilidades que se nos ocurr'ian eran muchas. Y todas parec'ian igual de v'alidas y \italica{buenas}. Eso generaba que todo el grupo tenga que estar reunido haciendo de a una cosa a la vez, para poder debatir entre nosotros. Y la consecuencia fue que los avances eran de a peque'nos pasos, por no poder hacer mucho por separado (y encima no es f'acil tener a todo el grupo reunido en todo momento). Pero igualmente, se lleg'o a un punto cuando ya todos comprend'iamos bastante m'as del tema, en donde pudimos separarnos los diagramas y redacci'on del informe. 

Pero para el TP2 'este cuello de botella se increment'o. Aqu'i la 'unica divisi'on posible, a priori, fue o hacer el DC o hacer los DS. Los segundos no se pod'ian hacer si no se ten'ia el primero ya bien definido. Y el DC es at'omico: ten'iamos que estar de nuevo todos juntos deliberando sobre el mejor criterio de dise'no a utilizar y que es mas \italica{lindo} y que es m'as \italica{feo}. 'Esto gener'o que ahora los avances fuesen a paso de hormiga. Y encima, la utilizaci'on err'onea del MVC junto al cambio de paradigma nos consumi'o mucho tiempo. Pero gracias a las sucesivas extensiones que nos brindaron, llegamos a terminar todo lo que quer'iamos hacer.


\subsection{Conclusiones finales}
Entre todos creemos que 'este fue el trabajo pr'actico m'as largo en lo que llevamos de la carrera. Creemos que las cosas las fuimos haciendo en forma lenta, pero la verdad que de tenerlo que hacer nuevamente utilizar'iamos las mismas metodolog'ias. Capaz que nustra forma de trabajo no es eficiente y de ah'i la tardanza. Capaz le dedicamos mucho tiempo a pensar en la \italica{mejor} soluci'on cuando el objetivo del trabajo no era para tanto. No lo sabemos. Sea como sea, logramos terminarlo :)
