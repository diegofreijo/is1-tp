En la presente secci'on agregaremos aclaraciones de las decisiones que el grupo fue tomando en el transcurso del dise'no. Adem'as expondremos otras alternativas que se nos ocurrieron ante cada problema. 

\subsection{}


\begin{itemize}
\item Las fachadas necesitan responder informaci'on del estilo \italica{pude hacer la acci'on} / \italica{no pude hacer la acci'on}, y es por eso que casi todas las acciones devuelven un Boolean. Pero hay otras acciones que adem'as necesitan devolver informaci'on espec'ifica de la acci'on. Para resolver la situaci'on se nos ocurri'o:
	\begin{itemize}
	\item Que las acciones devuelvan un objeto RespuestaDelModelo. 'Este deber'ia ser parecido a un \verb|Diccionario<nombre_parametro:Texto, valor_parametro:Objeto>| para que sea abarcativo a todos los pedidos de todas las clases (incluso los que no existen pero pueden ser agregados en un futuro, lo mismo vale para nuevas fachadas). Pero har'ia falta \italica{downcastear} para usar cada valor devuelto y no nos parece \italica{prolijo}.
	\item Idem al punto anterior pero que cada acci'on devuelva una estructura espec'ifica para 'esa acci'on la cual solamente es una lista de los par'ametros de respuesta. La ventaja con la opci'on anterior es que es ahora se tienen los valores fuertemente tipados. La gran desventaja es que se incrementan en gran n'umero la cantidad de clases del diagrama, adem'as que se dificulta agregar nuevas acciones porque hace falta agregar una clase que represente la respuesta.
	\item Que se guarde toda esa informaci'on y sea accedida a travez de metodos de consulta. 'Esto disminuye un poco la cohesi'on de la fachada porque ahora se deben agregar m'etodos de consulta del estilo DetalleUltimaAccion (devuelve el mensaje de respuesta de porque fue rechazada la 'ultima acci'on realizada, o los mensajes de bienvenida si fue aceptada). Dada la simpleza de 'esta opci'on, porque los par'ametros a devolver no son numerosos y porque nuestro servidor funciona mono-thread (de no ser asi, la 'ultima acci'on no se sabe si es la realizada en el procesamiento del pedido actual o el de otro thread) , fue la elegida.
	\end{itemize}

\item En el protocolo, entrarCraps tiene como sem'antica que cuando IdMesa posee un valor nulo (vac'io) es porque hace falta crear una mesa. Las opciones para 'esto son:
	\begin{itemize}
	\item Hacer que el MensajeroDeEntrada verifique con un condicional si primero llama a CrearMesa o no seg'un si 'este texto es nulo o no. 'Esto har'ia que haya logica de negocio en el mensajero.
	\item Hacer que haya una sobrecarga de EntrarJugadorMesaCraps que una no reciba el id de mesa y as'i se asuma que hay que crear la mesa. Pero el mensajero deber'ia seguir teniendo l'ogica de negocio dentro porque tiene que decidir a cual llamar.
	\item Que la fachada haga la verificaci'on. Esto genera que no se entienda del todo bien la l'ogica porque no es intuitivo que si el id de mesa es nulo hay que crear una mesa nueva, pero es la mejor opcion en comparaci'on con las otras 3 porque mantiene la l'ogica de negocio en el Modelo. Adem'as, es una fachada, por lo que tener l'ogica de control de flujo no est'a mal.
	\end{itemize}

\item Las fachadas muestran un comportamiento \italica{plug and play} desde afuera, algo as'i como que desde afuera se pueden sacar y poner juegos de la nada utilizando formas de representaci'on completamente diferente desde afuera, por ejemplo. Pero en el fondo no es tan as'i. Por ejemplo, las fachadas van a ejecutar logica de validacion, y esta l'ogica muchas veces va a necesitar cosas que no son tan dependientes del juego en si (por ejemplo, del LobbyCasino). No estamos diciendo que nuestro dise'no no sea extensible (en efecto, lo es y se explica en la secci'on de an'alisis), solamete es un dato curioso que vale la pena notar.

\item Hacemos algunas verificaciones de si existe o no algo comparando con null para simplificar (por ejemplo, ObtenerMesaCraps de MesasAbiertas devuelve null cuando no existe la mesa con el id dado). Podriamos tambien agregar mas m'etodos que respondan con un Booleano si existe o no lo que busco, pero deber'iamos agregar varios metodos m'as. Por eso, y para mantener la simpleza del dise'no, se opt'o por utilizar comparaci'on por null (disminuyendo en peque'na medida el significado a simple vista del m'etodo).

\item Estamos asumiendo que el nombre de un jugador lo identifica un'ivocamente y no pueden existir dos jugadores con el mismo nombre. Lo mismo aplica para las mesas y su IdMesa.

\item En la resolucion de las apuestas, para poder reutilizar la l'ogica de TipoJugada, se le necesitan pasar las jugadas, apuestas y resultados en forma generica, es decir, los objetos abstractos (Jugada en lugar de JugadaCraps, por ejemplo). 'Esto genera que haya que terminar haciendo un casteo cuando se necesite informaci'on especifica (por ejemplo, el valor de los dados en un resultado craps o el valor del punto en una jugada craps). Y aunque no nos guste mucho usar downcast, vali'o la pena hacerlo con el objeto de hacer la l'ogica de TipoJugada bien gen'erica como para usarla en cualquier apuesta de cualquier juego.

\item No implementamos el cancelamiento de apuestas en craps porque el protocolo no lo soportaba.

\item En TirarDados de MesaCraps tuvimos que agregar un condicional para actuar en funci'on del estado de la ronda. Esto se podria haber solucionado haciendo que el estado de la ronda pase a ser una clase abstracta en donde cada estado herede de 'este y que la l'ogica necesaria sea implementada por cada concreta (se poodr'ia hablar de patr'on State). Pero por simpleza y porque es l'ogica muy ligada al juego, lo preferimos dejar como est'a.

\item Si se desea cambiar el medio de transmisi'on de los mensajes entre el cliente y el servidor, solamente hay que agregar nuevas clases que realicen las interfaces IObtenedorPedidos e IDespachadorRespuestasEspecifico y, en el inicio del servidor, asignarle a ReceptorPedidos y DespachadorRespuestas las instancias de 'estas nuevas clases (de forma similar a como se est'a haciendo ahora con ObtenedorPedidosArchivo y DespachadorPedidosArchivo).

\item Notar que hubo cierto acoplamiento en el dise'no al XML como estructura de pedidos. Y nos pareci'o razonable que as'i sea. Hacer que el medio por el cual viajan los mensajes s'i que deber'ia ser extensible porque en un futuro se pueden optar por formas mas eficientes, seguras, baratas, etc. Pero no le encontramos sentido (ni se especific'o un requerimiento) hacer que la aplicaci'on \italica{hable distintos idiomas}. De 'ultima, si es muy necesario realizar un cambio en la estructura 'este se sentir'ia fuertemente en los manejadores de los mensajeros (hay que cambiarlos casi completamente), en menor medida en la capa de comunicaci'on pero absolutamente nada en el Modelo (esta abstra'ido de quien o como lo usan).

\end{itemize}


\subsection{Sobre el observador para el EventHandler}
Para el E/H necesario en el juego de craps implementamos el patron observer entre las mesas de craps (observado) y NotificadorDeCambiosAClientes, una clase del MensajeroDeSalida (observador). La suscripci'on es s'olo una: cuando se notifica un cambio de estado el mensajero va a recuperar del modelo la info que necesita de la mesa que acaba de cambiar de estado (en el mensaje de notificaci'on viaja el numero de mesa para identificarla)  para armar el XML. Despu'es, el observador revisa que jugadores hay en 'esa mesa y para cada uno busca en un diccionario suyo destinado a tal fin (terminales) en que terminal virtual est'a. En 'esta taba es donde los jugadores realizan la suscripcion, porque contra el modelo no lo deben hacer (el Modelo no deber'ia conocer que existen terminales virtuales). Notar que de 'esta forma, la l'ogica de negocio que dice \italica{todos los jugadores en una mesa deben enterarse de los cambios en esa mesa} se la est'a definiendo en el MensajeroDeSalida y no el Modelo (cuando se defini'o en un principio que la l'ogica de negocio estar'a s'olo en el Modelo), pero de no ser asi hace falta que el modelo haga la suscripci'on y conozca las terminales virtuales (es decir, tambi'en se defini'o que lo que est'a en el Modelo es l'ogica de negocio). Pero como es una l'ogica m'inima, y encima en ning'un momento el MensajeroDeSalida utiliza estructuras internas del Modelo (todos los datos necesarios los toma de fachada correspondiente) es que decidimos hacerlo de 'esta forma.

Otra opci'on ser'ia que los observadores sean directamente cada terminal virtual. Pero 'esto no se puede hacer porque el protocolo no soporta los mensajes que necesitar'ia env'iar el cliente para obtener la informaci'on necesaria de la mesa que cambi'o el estado.

Cada mesa obtiene cuando es constru'ida el observador al cual le deber'ia notificar los cambios. Para ello, MesasAbiertas ya tiene la instancia del observador y es ella quien se la pasa a las mesas que crea (notar que solo ella crea las mesas).

Notar que cuando alguien entra, el MensajeroDeEntrada debe hacer un NotificarEstadoCraps con el que recien entr'o para que le llegue el estado de la mesa en el momento en que entr'o (notar que el observer no lo va a incluir en la actualizacion generadoa por \italica{entr'o alguien a la mesa} porque en ese entonces todav'ia no estaba suscripto). 'Esto puede ser considerado l'ogica de negocio que est'a realizando el MensajeroDeEntrada, pero es la mejor opci'on que hay. Tambi'en se puede poner un nuevo m'etodo que me diga si se puede o no hacer la entrada pero no la realice y otro metodo que haga la entrada real, donde realmente se hace la notificacio del cambio, pero igual deber'iamos poner l'ogica en el MensajeroDeEntrada que haga o no el llamado correspondiente a hacer la notificaci'on real cuando la validaci'on se pudo hacer. As'i que optamos por la opci'on sencilla y dejarlo como la primer alternativa. Con la salida 'esto no pasa porque el cambio en la mesa es justamente que el jugador que sale no est'a m'as, entonces cuando el observer quiera notificar no va a encontrar al que esta saliendo de la mesa.


\subsection{Sobre el modo dirigido}
La configuraci'on de modo dirigido (o incluso la falta de 'este en el estado Azar) se realiza a nivel de mesa para cualquier estado y a travez del selector de turno asignado a esa mesa. Si llega un mensaje de configuracion para hacer el tipo de jugada de una mesa siempre feliz, se actualiza el estado solamente para la mesa que se especif'ica en el mensaje. En cambio si llega otro (es decir, uno que se especific'o que apunta a nivel de juego) se hace que cada mesa de 'ese juego actualice su estado. 

Notar que 'esto genera que cualquier cantidad de mesas puedan estar configuradas para que siempre saquen jugada feliz. Por consiguiente, se podr'ia considerar que dos o m'as mesas sacan jugada feliz \italica{simult'aneamente}. Y en principio parecer'ia que no se cumple el requerimiento planteado por los Timbalistas que plantea que no pueden suceder simult'aneamente en dos o m'as mesas del casino una jugada feliz. Pero en la minuta de relevamiento se establece de forma m'as espec'ifica que no puede suceder una jugada feliz hasta que no se pague una jugada feliz ocurrida anteriormente. Y 'esto no sucede, dado que la ejecuci'on de la jugada, la decisi'on de su tipo y el pago de los premios se hacen en el mismo mensaje (en el de tirarCraps y girarRodillos, dependiendo del juego). Adem'as, nuestro servidor es mono-thread, por lo que efectivamente ning'un mensaje de tiro nuevo se levantar'a para procesar hasta no haber procesado el actual. Y en procesar se incluyen los pagos (no solo la asignaci'on de mas saldo al objeto jugador, si no adem'as las notificaciones de respuesta de lo que sucedio e incluso las notificaciones por E/H en craps). Es por eso que los requerimientos exigidos se siguen cumpliendo.

Algo con lo cual uno no podr'ia estar muy de acuerdo con lo dicho anteriormente es que as'i y todo puede pasar que a dos jugadores en diferentes mesas les aparezca a la vez que su jugada fue feliz. 'Esto puede pasar si el mensaje de respuesta del primer jugador se tard'o en leer por el lado del cliente, y lo levant'o junto al cliente del segundo jugador cuand se genero la respuesta de 'este (y en ambas respuestas se decia que la jugada fue feliz). Para reparrar 'esta situaci'on lo que hay que hacer no es ''no hacer que jugadas sucesivas sean felices'' si no hacer que hasta que todos los clientes no hayan levantado sus mensajes no seguir procesando otro pedido de entrada. Pero tanto detalle nos termin'o pareciendo innecesario y esa situaci'on dejamos que pueda ocurrir.



\subsection{Notas varias}
